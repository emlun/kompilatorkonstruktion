\subsection{Theoretical Background}

There is not a lot of complex theory behind simple C++ style template expansion, in theory all you
have to do is create a new class or method where you have replaced every instance of a template
parameter with the type value of the parameter.  If you for example have a template class
\textbf{Foo$\langle$T,V$\rangle$} and you invoke it by calling \textbf{bar = new
Foo$\langle$Int,Bool$\rangle$}, all you have to do is copy the class definition for
\textbf{Foo$\langle$T,V$\rangle$} and replace all T:s with Int and V:s with Bool. For simple
programs this can be done by hand without much effort, but for more complex programs it can be hard
to calculate which ``real'' versions of the template classes are necessary, and expanding them all
might be impossible. We've solved this problem by iteratively searching for template references and
expanding the class or method templates one by one. In the end the result is a normal KOOL source
file without any of our extended grammar, except that the identifiers of expanded classes and
methods will contain illegal characters.

\subsection{Implementation Details}

We make use of some properties of the KOOL language and our template specification to make the
implementation simple:

\begin{itemize}
    \item All classes are declared at the top level
    \item All methods are declared at the top level of a class
    \item The language has no inclusion or import feature
    \item Template parameters may not shadow class declarations
    \item Method template parameters may not shadow class template parameters
\end{itemize}

These properties allow for easy lookup of templates, for example there is no need to search
for template declarations in statements. This makes the implementation easy --- in fact, class
templates can be completely expanded as a separate phase before name analysis since the name lookup
in this case is so simple. Method template expansion is done as part of the type checking phase,
since we need to know the receiver type of a method call before we can look up the method template.
The last two points mean we can replace template parameters in expanded templates based on name
alone, without needing to resolve whether a type name refers to a concrete class or a type
parameter.

\subsubsection{Iterative expansion}

Since templates may reference themselves or other templates, template expansion is done iteratively.
The class template expansion phase loops back to itself if any templates were expanded, and the
method template expansion subphase loops back to class template expansion if any templates were
expanded. \figref{compiler-flowchart} illustrates the flow between compiler phases.

\begin{figure}[hbtp]
  \includegraphics[width=0.5\textwidth]{compiler-flowchart}
  \caption{Compiler phases flow diagram. Since templates may reference other templates that may in
    turn need expansion, the template expansion phases must be iterated until all template
    references have been replaced with references to concrete expanded types or methods.}
  \label{fig:compiler-flowchart}
\end{figure}

In each iteration of the template expansion phases, only the leaves in each tree of template
arguments is expanded. This helps ensure that the types passed as template arguments are always
complete --- for instance, consider the template reference
\textbf{Maybe\tmpl{LinkedList\tmpl{Int}}}. If we were to expand the \textbf{Maybe} template first,
we would need to account for the fact that its type argument is also a template type. By instead
only expanding the innermost template references --- \textbf{LinkedList\tmpl{Int}} in this case ---
in each iteration, the procedure is made simpler because we know the type arguments will always be
concrete types.

\subsubsection{Avoiding name collisions}

In order to guarantee that the names of expanded classes and methods don't collide with existing
classes and methods, the names of expanded classes and methods --- which are only used internally
--- use the characters \textbf{\$} and \textbf{,} to denote template arguments. For instance, the
expanded name of the class \textbf{Pair\tmpl{LinkedList\tmpl{Int},String}} is
\textbf{Pair\$LinkedList\$Int,String}. Since these additional characters are not allowed by the KOOL
syntax, expanded names can never collide with names of plain classes or methods. This naming scheme
also guarantees that expanded names cannot collide with each other, since every template must always
be referenced with the same number of template arguments. Knowing that the template \textbf{A} takes
2 type parameters, \textbf{B} takes 1 and \textbf{C} takes 3, we can uniquely reconstruct the
template reference \textbf{A\tmpl{B\tmpl{C\tmpl{Int,Bool,Int[]}}, C\tmpl{B\tmpl{Bool},Bool,Bool}}}
from the name \textbf{A\$B\$C\$Int,Bool,Int[], C\$B\$Bool,Bool,Bool}.


\subsubsection{Infinite template recursion}

Recursive templates can cause problems. Consider what would happen if the class template
\textbf{Foo\tmpl{T}} has a member variable of type \textbf{Foo\tmpl{Foo\tmpl{T}}}. After expanding
\textbf{Foo\tmpl{Int}}, we would then need to expand \textbf{Foo\tmpl{Foo\$Int}}, and then
\textbf{Foo\tmpl{Foo\$Foo\$Int}} and so on. The easy way to make sure the compiler detects this and
halts is to simply not allow the class template expansion phase to run more than a set number of
times. Our implementation allows a maximum of 100 iterations. It might be possible to detect
circular references that would result in infinite recursion through static analysis, but it would be
nontrivial since such circular references might consist of multiple steps in several different
templates.

\subsubsection{Special handling of templates in the AST}

Our implementation stores the class and method templates as ordinary class and method declarations
in the AST, but with accompanying template information. Since these classes and methods will
inevitably refer to undeclared types, they are ignored in the name analysis step. The template
expansion routines also don't search within templates for template references to replace, since that
would destroy the templates. After all template expansion is finished --- when the decision after
method template expansion in \figref{compiler-flowchart} is ``No'' --- all class and method
templates are removed from the AST before proceeding to type checking.


\emph{Describe all non-obvious tricks you used. Tell us what you thought was hard and
why. If it took you time to figure out the solution to a problem, it probably
means it wasn't easy and you should definitely describe the solution in details
here. If you used what you think is a cool algorithm for some problem, tell us.
Do not however spend time describing trivial things (we know what a tree traversal
is, for instance).}

\emph{After reading this section, we should be convinced that you knew what you were
doing when you wrote your extension, and that you put some extra consideration
for the harder parts.}
