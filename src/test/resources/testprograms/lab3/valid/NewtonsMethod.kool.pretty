object NewtonsMethod /* NewtonsMethod#0 */ {
  def main() : Unit = {
    println( ("Final result: " + new NM/**/().sqrt/**/ ( 2 ).toString/**/ (  )) );
  }
}

class NM /* NM#1 */ {
  def sqrt /* sqrt#6 */ ( n /* n#5 */ : Int ) : Real/**/ = {
    var guess /* guess#2 */ /* guess#2 */ : Real/**/;
    var orig /* orig#3 */ /* orig#3 */ : Real/**/;
    var result /* result#4 */ /* result#4 */ : Real/**/;
    guess/**/ = new Real/**/().init/**/ ( 1, 4 );
    orig/**/ = new Real/**/().init/**/ ( n/**/, 4 );
    result/**/ = this/**/.sqrtIter/**/ ( guess/**/, 0, 5, orig/**/ );
    return result/**/;
  }

  def sqrtIter /* sqrtIter#14 */ ( guess /* guess#10 */ : Real/**/, i /* i#11 */ : Int, maxIter /* maxIter#12 */ : Int, original /* original#13 */ : Real/**/ ) : Real/**/ = {
    var average /* average#7 */ /* average#7 */ : Real/**/;
    var quotient /* quotient#8 */ /* quotient#8 */ : Real/**/;
    var result /* result#9 */ /* result#9 */ : Real/**/;
    if ( (i/**/ == maxIter/**/) )
      {
        result/**/ = guess/**/;
      }
    else
      {
        println( ((("Iteration " + i/**/) + ": Guess is ") + guess/**/.toString/**/ (  )) );
        quotient/**/ = original/**/.divide/**/ ( guess/**/ );
        average/**/ = guess/**/.plus/**/ ( quotient/**/ ).divide/**/ ( new Real/**/().init/**/ ( 2, 4 ) );
        result/**/ = this/**/.sqrtIter/**/ ( average/**/, (i/**/ + 1), maxIter/**/, original/**/ );
      }
    return result/**/;
  }
}

class Real /* Real#18 */ {
  var integerPart /* integerPart#15 */ /* integerPart#15 */ : Int;
  var digits /* digits#16 */ /* digits#16 */ : Int[ ];
  var util /* util#17 */ /* util#17 */ : Util/**/;
  def init /* init#22 */ ( intPart /* intPart#20 */ : Int, digitsCount /* digitsCount#21 */ : Int ) : Real/**/ = {
    var i /* i#19 */ /* i#19 */ : Int;
    util/**/ = new Util/**/();
    integerPart/**/ = intPart/**/;
    digits/**/ = new Int [ digitsCount/**/ ];
    i/**/ = 0;
    while ( (i/**/ < digitsCount/**/) )
      {
        digits/**/[ i/**/ ] = 0;
        i/**/ = (i/**/ + 1);
      }
    return this/**/;
  }

  def getDigits /* getDigits#23 */ (  ) : Int[ ] = {
    return digits/**/;
  }

  def getIntegerPart /* getIntegerPart#24 */ (  ) : Int = {
    return integerPart/**/;
  }

  def setIntegerPart /* setIntegerPart#26 */ ( p /* p#25 */ : Int ) : Real/**/ = {
    integerPart/**/ = p/**/;
    return this/**/;
  }

  def divide /* divide#35 */ ( other /* other#34 */ : Real/**/ ) : Real/**/ = {
    var i /* i#27 */ /* i#27 */ : Int;
    var int1 /* int1#28 */ /* int1#28 */ : Int;
    var int2 /* int2#29 */ /* int2#29 */ : Int;
    var len /* len#30 */ /* len#30 */ : Int;
    var otherDigits /* otherDigits#31 */ /* otherDigits#31 */ : Int[ ];
    var f /* f#32 */ /* f#32 */ : Frac/**/;
    var result /* result#33 */ /* result#33 */ : Real/**/;
    if ( (digits/**/.length < other/**/.getDigits/**/ (  ).length) )
      {
        len/**/ = digits/**/.length;
      }
    else
      {
        len/**/ = other/**/.getDigits/**/ (  ).length;
      }
    int1/**/ = this/**/.getIntegerPart/**/ (  );
    int2/**/ = other/**/.getIntegerPart/**/ (  );
    i/**/ = 0;
    otherDigits/**/ = other/**/.getDigits/**/ (  );
    while ( (i/**/ < len/**/) )
      {
        int1/**/ = ((int1/**/ * 10) + digits/**/ [ i/**/ ]);
        int2/**/ = ((int2/**/ * 10) + otherDigits/**/ [ i/**/ ]);
        i/**/ = (i/**/ + 1);
      }
    f/**/ = new Frac/**/().init/**/ ( int1/**/, int2/**/ );
    result/**/ = new Real/**/().init/**/ ( 3, 4 ).evalFrac/**/ ( f/**/ );
    return result/**/;
  }

  def evalFrac /* evalFrac#40 */ ( frac /* frac#39 */ : Frac/**/ ) : Real/**/ = {
    var leftover /* leftover#36 */ /* leftover#36 */ : Int;
    var i /* i#37 */ /* i#37 */ : Int;
    var den /* den#38 */ /* den#38 */ : Int;
    den/**/ = frac/**/.getDenominator/**/ (  );
    integerPart/**/ = (frac/**/.getNumerator/**/ (  ) / den/**/);
    if ( !frac/**/.isPos/**/ (  ) )
      {
        integerPart/**/ = (0 - integerPart/**/);
      }
    leftover/**/ = util/**/.mod/**/ ( frac/**/.getNumerator/**/ (  ), den/**/ );
    i/**/ = 0;
    while ( (i/**/ < digits/**/.length) )
      {
        leftover/**/ = (10 * leftover/**/);
        digits/**/[ i/**/ ] = (leftover/**/ / den/**/);
        leftover/**/ = util/**/.mod/**/ ( leftover/**/, den/**/ );
        i/**/ = (i/**/ + 1);
      }
    return this/**/;
  }

  def plus /* plus#49 */ ( other /* other#48 */ : Real/**/ ) : Real/**/ = {
    var len /* len#41 */ /* len#41 */ : Int;
    var od /* od#42 */ /* od#42 */ : Int[ ];
    var resDig /* resDig#43 */ /* resDig#43 */ : Int[ ];
    var carry /* carry#44 */ /* carry#44 */ : Int;
    var i /* i#45 */ /* i#45 */ : Int;
    var sum /* sum#46 */ /* sum#46 */ : Int;
    var result /* result#47 */ /* result#47 */ : Real/**/;
    od/**/ = other/**/.getDigits/**/ (  );
    if ( (digits/**/.length < od/**/.length) )
      {
        len/**/ = digits/**/.length;
      }
    else
      {
        len/**/ = od/**/.length;
      }
    result/**/ = new Real/**/().init/**/ ( 0, len/**/ );
    resDig/**/ = result/**/.getDigits/**/ (  );
    carry/**/ = 0;
    i/**/ = (len/**/ - 1);
    while ( !(i/**/ < 0) )
      {
        sum/**/ = ((digits/**/ [ i/**/ ] + od/**/ [ i/**/ ]) + carry/**/);
        carry/**/ = (sum/**/ / 10);
        resDig/**/[ i/**/ ] = util/**/.mod/**/ ( sum/**/, 10 );
        i/**/ = (i/**/ - 1);
      }
    return result/**/.setIntegerPart/**/ ( ((integerPart/**/ + other/**/.getIntegerPart/**/ (  )) + carry/**/) );
  }

  def toString /* toString#52 */ (  ) : String = {
    var ret /* ret#50 */ /* ret#50 */ : String;
    var i /* i#51 */ /* i#51 */ : Int;
    ret/**/ = (("" + integerPart/**/) + ".");
    i/**/ = 0;
    while ( (i/**/ < digits/**/.length) )
      {
        ret/**/ = (ret/**/ + digits/**/ [ i/**/ ]);
        i/**/ = (i/**/ + 1);
      }
    return ret/**/;
  }
}

class Frac /* Frac#57 */ {
  var numerator /* numerator#53 */ /* numerator#53 */ : Int;
  var denominator /* denominator#54 */ /* denominator#54 */ : Int;
  var sign /* sign#55 */ /* sign#55 */ : Bool;
  var util /* util#56 */ /* util#56 */ : Util/**/;
  def init /* init#60 */ ( n /* n#58 */ : Int, d /* d#59 */ : Int ) : Frac/**/ = {
    util/**/ = new Util/**/();
    numerator/**/ = util/**/.abs/**/ ( n/**/ );
    denominator/**/ = util/**/.abs/**/ ( d/**/ );
    sign/**/ = (((n/**/ < 0) && (d/**/ < 0)) || (((0 < n/**/) || (n/**/ == 0)) && ((0 < d/**/) || (d/**/ == 0))));
    return this/**/.simplify/**/ (  );
  }

  def getNumerator /* getNumerator#61 */ (  ) : Int = {
    return numerator/**/;
  }

  def getDenominator /* getDenominator#62 */ (  ) : Int = {
    return denominator/**/;
  }

  def setPos /* setPos#64 */ ( positive /* positive#63 */ : Bool ) : Frac/**/ = {
    sign/**/ = positive/**/;
    return this/**/;
  }

  def isPos /* isPos#65 */ (  ) : Bool = {
    return sign/**/;
  }

  def simplify /* simplify#67 */ (  ) : Frac/**/ = {
    var gcd_ /* gcd_#66 */ /* gcd_#66 */ : Int;
    if ( (!(numerator/**/ == 0) && !(denominator/**/ == 0)) )
      {
        gcd_/**/ = util/**/.gcd/**/ ( numerator/**/, denominator/**/ );
        if ( !(gcd_/**/ == 1) )
          {
            numerator/**/ = (numerator/**/ / gcd_/**/);
            denominator/**/ = (denominator/**/ / gcd_/**/);
          }
      }
    return this/**/;
  }

  def plus /* plus#72 */ ( other /* other#71 */ : Frac/**/ ) : Frac/**/ = {
    var lcm /* lcm#68 */ /* lcm#68 */ : Int;
    var lfac /* lfac#69 */ /* lfac#69 */ : Int;
    var rfac /* rfac#70 */ /* rfac#70 */ : Int;
    lcm/**/ = util/**/.lcm/**/ ( denominator/**/, other/**/.getDenominator/**/ (  ) );
    lfac/**/ = (lcm/**/ / denominator/**/);
    if ( !sign/**/ )
      {
        lfac/**/ = (0 - lfac/**/);
      }
    rfac/**/ = (lcm/**/ / other/**/.getDenominator/**/ (  ));
    if ( !other/**/.isPos/**/ (  ) )
      {
        rfac/**/ = (0 - rfac/**/);
      }
    return new Frac/**/().init/**/ ( ((lfac/**/ * numerator/**/) + (rfac/**/ * other/**/.getNumerator/**/ (  ))), lcm/**/ );
  }

  def minus /* minus#74 */ ( other /* other#73 */ : Frac/**/ ) : Frac/**/ = {
    return this/**/.plus/**/ ( other/**/.negative/**/ (  ) );
  }

  def times /* times#76 */ ( other /* other#75 */ : Frac/**/ ) : Frac/**/ = {
    return new Frac/**/().init/**/ ( (numerator/**/ * other/**/.getNumerator/**/ (  )), (denominator/**/ * other/**/.getDenominator/**/ (  )) ).simplify/**/ (  ).setPos/**/ ( ((this/**/.isPos/**/ (  ) && other/**/.isPos/**/ (  )) || (!this/**/.isPos/**/ (  ) && !other/**/.isPos/**/ (  ))) );
  }

  def divided /* divided#78 */ ( other /* other#77 */ : Frac/**/ ) : Frac/**/ = {
    return this/**/.times/**/ ( other/**/.inverse/**/ (  ) );
  }

  def inverse /* inverse#79 */ (  ) : Frac/**/ = {
    return new Frac/**/().init/**/ ( denominator/**/, numerator/**/ );
  }

  def negative /* negative#80 */ (  ) : Frac/**/ = {
    return new Frac/**/().init/**/ ( numerator/**/, denominator/**/ ).setPos/**/ ( false );
  }

  def toString /* toString#82 */ (  ) : String = {
    var result /* result#81 */ /* result#81 */ : String;
    if ( sign/**/ )
      {
        result/**/ = "";
      }
    else
      {
        result/**/ = "-";
      }
    return (((result/**/ + numerator/**/) + "/") + denominator/**/);
  }
}

class Util /* Util#83 */ {
  def abs /* abs#86 */ ( v /* v#85 */ : Int ) : Int = {
    var res /* res#84 */ /* res#84 */ : Int;
    if ( !(v/**/ < 0) )
      {
        res/**/ = v/**/;
      }
    else
      {
        res/**/ = (0 - v/**/);
      }
    return res/**/;
  }

  def gcd /* gcd#94 */ ( m_ /* m_#92 */ : Int, n_ /* n_#93 */ : Int ) : Int = {
    var t /* t#87 */ /* t#87 */ : Int;
    var r /* r#88 */ /* r#88 */ : Int;
    var result /* result#89 */ /* result#89 */ : Int;
    var m /* m#90 */ /* m#90 */ : Int;
    var n /* n#91 */ /* n#91 */ : Int;
    m/**/ = this/**/.abs/**/ ( m_/**/ );
    n/**/ = this/**/.abs/**/ ( n_/**/ );
    if ( (m/**/ < n/**/) )
      {
        t/**/ = m/**/;
        m/**/ = n/**/;
        n/**/ = t/**/;
      }
    r/**/ = this/**/.mod/**/ ( m/**/, n/**/ );
    if ( (r/**/ == 0) )
      {
        result/**/ = n/**/;
      }
    else
      {
        result/**/ = this/**/.gcd/**/ ( n/**/, r/**/ );
      }
    return result/**/;
  }

  def lcm /* lcm#97 */ ( m /* m#95 */ : Int, n /* n#96 */ : Int ) : Int = {
    return ((n/**/ * m/**/) / this/**/.gcd/**/ ( n/**/, m/**/ ));
  }

  def mod /* mod#100 */ ( m /* m#98 */ : Int, n /* n#99 */ : Int ) : Int = {
    return (m/**/ - (n/**/ * (m/**/ / n/**/)));
  }
}
